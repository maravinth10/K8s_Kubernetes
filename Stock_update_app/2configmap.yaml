apiVersion: v1
kind: ConfigMap
metadata:
  name: fastapi-requirements
data:
  requirements.txt: |
    fastapi
    uvicorn
    psycopg2-binary
    pandas
    yfinance
---	
apiVersion: v1
kind: ConfigMap
metadata:
  name: fastapi-code
data:
  main.py: |
    from fastapi import FastAPI
    import os
    import psycopg2
    import yfinance as yf
    from pydantic import BaseModel
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import HTMLResponse

    app = FastAPI()

    # Allow all CORS (frontend access)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    
    def get_connection():
        return psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            database=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )

    # Create table if it doesn't exist
    def create_portfolio_table():
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS portfolio (
            id SERIAL PRIMARY KEY,
            stock_name VARCHAR(255) NOT NULL,
            symbol VARCHAR(50) NOT NULL,
            buy_price NUMERIC NOT NULL,
            current_value NUMERIC NOT NULL,
            qty INTEGER NOT NULL
        )
        """)
        conn.commit()
        cursor.close()
        conn.close()

    create_portfolio_table()

    class Stock(BaseModel):
        stock_name: str
        symbol: str
        buy_price: float
        qty: int

    @app.get("/", response_class=HTMLResponse)
    def serve_home():
        with open("/code/index.html") as f:
            return f.read()

    @app.post("/add_stock")
    def add_stock(stock: Stock):
        try:
            conn = get_connection()
            cursor = conn.cursor()
            current_value = stock.buy_price * stock.qty
            cursor.execute(
                "INSERT INTO portfolio (stock_name, symbol, buy_price, current_value, qty) VALUES (%s, %s, %s, %s, %s)",
                (stock.stock_name, stock.symbol, stock.buy_price, current_value, stock.qty)
            )
            conn.commit()
            return {"status": "added"}
        except Exception as e:
            conn.rollback()
            return {"error": str(e)}
        finally:
            cursor.close()
            conn.close()

    @app.get("/get_portfolio")
    def get_portfolio():
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id, stock_name, symbol, buy_price, current_value, qty FROM portfolio")
            rows = cursor.fetchall()
            result = []
            for r in rows:
                result.append({
                    "id": r[0],
                    "stock_name": r[1],
                    "symbol": r[2],
                    "buy_price": float(r[3]),
                    "current_value": float(r[4]),
                    "qty": r[5]
                })
            return result
        finally:
            cursor.close()
            conn.close()

    @app.put("/update_stock/{id}")
    def update_stock(id: int, field: str, value: float):
        if field not in ["buy_price", "qty"]:
            return {"error": "Invalid field"}
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute(f"UPDATE portfolio SET {field}=%s WHERE id=%s", (value, id))
            conn.commit()
            return {"status": "updated"}
        finally:
            cursor.close()
            conn.close()

    @app.delete("/delete_stock/{id}")
    def delete_stock(id: int):
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute("DELETE FROM portfolio WHERE id=%s", (id,))
            conn.commit()
            return {"status": "deleted"}
        finally:
            cursor.close()
            conn.close()

    @app.get("/update_current_values")
    def update_current_values():
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id, symbol, qty FROM portfolio")
            rows = cursor.fetchall()
            for row in rows:
                id, symbol, qty = row
                data = yf.Ticker(symbol + ".NS")
                history = data.history(period="1d")
                if history.empty:
                    continue
                latest_price = history['Close'].iloc[-1]
                current_value = latest_price * qty
                cursor.execute(
                    "UPDATE portfolio SET current_value=%s WHERE id=%s",
                    (current_value, id)
                )
            conn.commit()
            return {"status": "updated"}
        finally:
            cursor.close()
            conn.close()



